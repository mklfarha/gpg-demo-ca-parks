// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: selects.sql

package ca_parksdb

import (
	"context"
)

const fetchEventByID = `-- name: FetchEventByID :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     id = ?
`

func (q *Queries) FetchEventByID(ctx context.Context, id string) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkID = `-- name: FetchEventByParkID :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    LIMIT ?, ?
`

type FetchEventByParkIDParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkID(ctx context.Context, arg FetchEventByParkIDParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkID, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatus = `-- name: FetchEventByParkIDAndStatus :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatus(ctx context.Context, arg FetchEventByParkIDAndStatusParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatus,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByCreatedAtASC = `-- name: FetchEventByParkIDAndStatusOrderedByCreatedAtASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByCreatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByCreatedAtASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByCreatedAtASC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByCreatedAtDESC = `-- name: FetchEventByParkIDAndStatusOrderedByCreatedAtDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByCreatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByCreatedAtDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByCreatedAtDESC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByEndDateASC = `-- name: FetchEventByParkIDAndStatusOrderedByEndDateASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY end_date ASC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByEndDateASCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByEndDateASC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByEndDateASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByEndDateASC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByEndDateDESC = `-- name: FetchEventByParkIDAndStatusOrderedByEndDateDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY end_date DESC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByEndDateDESCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByEndDateDESC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByEndDateDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByEndDateDESC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByStartDateASC = `-- name: FetchEventByParkIDAndStatusOrderedByStartDateASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY start_date ASC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByStartDateASCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByStartDateASC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByStartDateASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByStartDateASC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByStartDateDESC = `-- name: FetchEventByParkIDAndStatusOrderedByStartDateDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY start_date DESC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByStartDateDESCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByStartDateDESC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByStartDateDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByStartDateDESC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByUpdatedAtASC = `-- name: FetchEventByParkIDAndStatusOrderedByUpdatedAtASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByUpdatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByUpdatedAtASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByUpdatedAtASC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDAndStatusOrderedByUpdatedAtDESC = `-- name: FetchEventByParkIDAndStatusOrderedByUpdatedAtDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchEventByParkIDAndStatusOrderedByUpdatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchEventByParkIDAndStatusOrderedByUpdatedAtDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDAndStatusOrderedByUpdatedAtDESC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByCreatedAtASC = `-- name: FetchEventByParkIDOrderedByCreatedAtASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByCreatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByCreatedAtASC(ctx context.Context, arg FetchEventByParkIDOrderedByCreatedAtASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByCreatedAtASC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByCreatedAtDESC = `-- name: FetchEventByParkIDOrderedByCreatedAtDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByCreatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByCreatedAtDESC(ctx context.Context, arg FetchEventByParkIDOrderedByCreatedAtDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByCreatedAtDESC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByEndDateASC = `-- name: FetchEventByParkIDOrderedByEndDateASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY end_date ASC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByEndDateASCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByEndDateASC(ctx context.Context, arg FetchEventByParkIDOrderedByEndDateASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByEndDateASC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByEndDateDESC = `-- name: FetchEventByParkIDOrderedByEndDateDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY end_date DESC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByEndDateDESCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByEndDateDESC(ctx context.Context, arg FetchEventByParkIDOrderedByEndDateDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByEndDateDESC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByStartDateASC = `-- name: FetchEventByParkIDOrderedByStartDateASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY start_date ASC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByStartDateASCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByStartDateASC(ctx context.Context, arg FetchEventByParkIDOrderedByStartDateASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByStartDateASC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByStartDateDESC = `-- name: FetchEventByParkIDOrderedByStartDateDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY start_date DESC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByStartDateDESCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByStartDateDESC(ctx context.Context, arg FetchEventByParkIDOrderedByStartDateDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByStartDateDESC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByUpdatedAtASC = `-- name: FetchEventByParkIDOrderedByUpdatedAtASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByUpdatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByUpdatedAtASC(ctx context.Context, arg FetchEventByParkIDOrderedByUpdatedAtASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByUpdatedAtASC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByParkIDOrderedByUpdatedAtDESC = `-- name: FetchEventByParkIDOrderedByUpdatedAtDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     park_id = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchEventByParkIDOrderedByUpdatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchEventByParkIDOrderedByUpdatedAtDESC(ctx context.Context, arg FetchEventByParkIDOrderedByUpdatedAtDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByParkIDOrderedByUpdatedAtDESC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatus = `-- name: FetchEventByStatus :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchEventByStatusParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatus(ctx context.Context, arg FetchEventByStatusParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByCreatedAtASC = `-- name: FetchEventByStatusOrderedByCreatedAtASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByCreatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchEventByStatusOrderedByCreatedAtASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByCreatedAtDESC = `-- name: FetchEventByStatusOrderedByCreatedAtDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByCreatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchEventByStatusOrderedByCreatedAtDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByEndDateASC = `-- name: FetchEventByStatusOrderedByEndDateASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY end_date ASC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByEndDateASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByEndDateASC(ctx context.Context, arg FetchEventByStatusOrderedByEndDateASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByEndDateASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByEndDateDESC = `-- name: FetchEventByStatusOrderedByEndDateDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY end_date DESC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByEndDateDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByEndDateDESC(ctx context.Context, arg FetchEventByStatusOrderedByEndDateDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByEndDateDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByStartDateASC = `-- name: FetchEventByStatusOrderedByStartDateASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY start_date ASC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByStartDateASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByStartDateASC(ctx context.Context, arg FetchEventByStatusOrderedByStartDateASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByStartDateASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByStartDateDESC = `-- name: FetchEventByStatusOrderedByStartDateDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY start_date DESC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByStartDateDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByStartDateDESC(ctx context.Context, arg FetchEventByStatusOrderedByStartDateDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByStartDateDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByUpdatedAtASC = `-- name: FetchEventByStatusOrderedByUpdatedAtASC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByUpdatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchEventByStatusOrderedByUpdatedAtASCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchEventByStatusOrderedByUpdatedAtDESC = `-- name: FetchEventByStatusOrderedByUpdatedAtDESC :many
SELECT id, name, description, main_image, start_date, end_date, status, created_at, updated_at, park_id, user_id FROM event
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchEventByStatusOrderedByUpdatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchEventByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchEventByStatusOrderedByUpdatedAtDESCParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, fetchEventByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MainImage,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFeatureByID = `-- name: FetchFeatureByID :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
     id = ?
`

func (q *Queries) FetchFeatureByID(ctx context.Context, id string) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, fetchFeatureByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFeatureByStatus = `-- name: FetchFeatureByStatus :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchFeatureByStatusParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchFeatureByStatus(ctx context.Context, arg FetchFeatureByStatusParams) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, fetchFeatureByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFeatureByStatusOrderedByCreatedAtASC = `-- name: FetchFeatureByStatusOrderedByCreatedAtASC :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchFeatureByStatusOrderedByCreatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchFeatureByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchFeatureByStatusOrderedByCreatedAtASCParams) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, fetchFeatureByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFeatureByStatusOrderedByCreatedAtDESC = `-- name: FetchFeatureByStatusOrderedByCreatedAtDESC :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchFeatureByStatusOrderedByCreatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchFeatureByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchFeatureByStatusOrderedByCreatedAtDESCParams) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, fetchFeatureByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFeatureByStatusOrderedByUpdatedAtASC = `-- name: FetchFeatureByStatusOrderedByUpdatedAtASC :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchFeatureByStatusOrderedByUpdatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchFeatureByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchFeatureByStatusOrderedByUpdatedAtASCParams) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, fetchFeatureByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFeatureByStatusOrderedByUpdatedAtDESC = `-- name: FetchFeatureByStatusOrderedByUpdatedAtDESC :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchFeatureByStatusOrderedByUpdatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchFeatureByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchFeatureByStatusOrderedByUpdatedAtDESCParams) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, fetchFeatureByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByID = `-- name: FetchParkByID :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     id = ?
`

func (q *Queries) FetchParkByID(ctx context.Context, id string) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaID = `-- name: FetchParkByRecreationAreaID :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ?  
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaID(ctx context.Context, arg FetchParkByRecreationAreaIDParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaID, arg.RecreationAreaID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDAndStatus = `-- name: FetchParkByRecreationAreaIDAndStatus :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ? AND status = ?  
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDAndStatusParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Status           int32  `json:"status"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDAndStatus(ctx context.Context, arg FetchParkByRecreationAreaIDAndStatusParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDAndStatus,
		arg.RecreationAreaID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtASC = `-- name: FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtASC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtASCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Status           int32  `json:"status"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtASCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtASC,
		arg.RecreationAreaID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtDESC = `-- name: FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtDESC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtDESCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Status           int32  `json:"status"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtDESCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDAndStatusOrderedByCreatedAtDESC,
		arg.RecreationAreaID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtASC = `-- name: FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtASC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtASCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Status           int32  `json:"status"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtASCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtASC,
		arg.RecreationAreaID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtDESC = `-- name: FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtDESC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtDESCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Status           int32  `json:"status"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtDESCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDAndStatusOrderedByUpdatedAtDESC,
		arg.RecreationAreaID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDOrderedByCreatedAtASC = `-- name: FetchParkByRecreationAreaIDOrderedByCreatedAtASC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDOrderedByCreatedAtASCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDOrderedByCreatedAtASC(ctx context.Context, arg FetchParkByRecreationAreaIDOrderedByCreatedAtASCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDOrderedByCreatedAtASC, arg.RecreationAreaID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDOrderedByCreatedAtDESC = `-- name: FetchParkByRecreationAreaIDOrderedByCreatedAtDESC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDOrderedByCreatedAtDESCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkByRecreationAreaIDOrderedByCreatedAtDESCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDOrderedByCreatedAtDESC, arg.RecreationAreaID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDOrderedByUpdatedAtASC = `-- name: FetchParkByRecreationAreaIDOrderedByUpdatedAtASC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDOrderedByUpdatedAtASCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkByRecreationAreaIDOrderedByUpdatedAtASCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDOrderedByUpdatedAtASC, arg.RecreationAreaID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByRecreationAreaIDOrderedByUpdatedAtDESC = `-- name: FetchParkByRecreationAreaIDOrderedByUpdatedAtDESC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     recreation_area_id = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkByRecreationAreaIDOrderedByUpdatedAtDESCParams struct {
	RecreationAreaID string `json:"recreation_area_id"`
	Offset           int32  `json:"offset"`
	Limit            int32  `json:"limit"`
}

func (q *Queries) FetchParkByRecreationAreaIDOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkByRecreationAreaIDOrderedByUpdatedAtDESCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByRecreationAreaIDOrderedByUpdatedAtDESC, arg.RecreationAreaID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByStatus = `-- name: FetchParkByStatus :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchParkByStatusParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkByStatus(ctx context.Context, arg FetchParkByStatusParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByStatusOrderedByCreatedAtASC = `-- name: FetchParkByStatusOrderedByCreatedAtASC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkByStatusOrderedByCreatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchParkByStatusOrderedByCreatedAtASCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByStatusOrderedByCreatedAtDESC = `-- name: FetchParkByStatusOrderedByCreatedAtDESC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkByStatusOrderedByCreatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkByStatusOrderedByCreatedAtDESCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByStatusOrderedByUpdatedAtASC = `-- name: FetchParkByStatusOrderedByUpdatedAtASC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkByStatusOrderedByUpdatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkByStatusOrderedByUpdatedAtASCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkByStatusOrderedByUpdatedAtDESC = `-- name: FetchParkByStatusOrderedByUpdatedAtDESC :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkByStatusOrderedByUpdatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkByStatusOrderedByUpdatedAtDESCParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureID = `-- name: FetchParkHasFeatureByFeatureID :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ?  
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDParams struct {
	FeatureID string `json:"feature_id"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureID(ctx context.Context, arg FetchParkHasFeatureByFeatureIDParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureID, arg.FeatureID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDAndStatus = `-- name: FetchParkHasFeatureByFeatureIDAndStatus :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ? AND status = ?  
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDAndStatusParams struct {
	FeatureID string `json:"feature_id"`
	Status    int32  `json:"status"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDAndStatus(ctx context.Context, arg FetchParkHasFeatureByFeatureIDAndStatusParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDAndStatus,
		arg.FeatureID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtASC = `-- name: FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtASCParams struct {
	FeatureID string `json:"feature_id"`
	Status    int32  `json:"status"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtASC,
		arg.FeatureID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtDESC = `-- name: FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtDESCParams struct {
	FeatureID string `json:"feature_id"`
	Status    int32  `json:"status"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDAndStatusOrderedByCreatedAtDESC,
		arg.FeatureID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtASC = `-- name: FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtASCParams struct {
	FeatureID string `json:"feature_id"`
	Status    int32  `json:"status"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtASC,
		arg.FeatureID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtDESC = `-- name: FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtDESCParams struct {
	FeatureID string `json:"feature_id"`
	Status    int32  `json:"status"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDAndStatusOrderedByUpdatedAtDESC,
		arg.FeatureID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDOrderedByCreatedAtASC = `-- name: FetchParkHasFeatureByFeatureIDOrderedByCreatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDOrderedByCreatedAtASCParams struct {
	FeatureID string `json:"feature_id"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDOrderedByCreatedAtASC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDOrderedByCreatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDOrderedByCreatedAtASC, arg.FeatureID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDOrderedByCreatedAtDESC = `-- name: FetchParkHasFeatureByFeatureIDOrderedByCreatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDOrderedByCreatedAtDESCParams struct {
	FeatureID string `json:"feature_id"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDOrderedByCreatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDOrderedByCreatedAtDESC, arg.FeatureID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDOrderedByUpdatedAtASC = `-- name: FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtASCParams struct {
	FeatureID string `json:"feature_id"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDOrderedByUpdatedAtASC, arg.FeatureID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByFeatureIDOrderedByUpdatedAtDESC = `-- name: FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     feature_id = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtDESCParams struct {
	FeatureID string `json:"feature_id"`
	Offset    int32  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByFeatureIDOrderedByUpdatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByFeatureIDOrderedByUpdatedAtDESC, arg.FeatureID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByID = `-- name: FetchParkHasFeatureByID :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     id = ?
`

func (q *Queries) FetchParkHasFeatureByID(ctx context.Context, id string) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkID = `-- name: FetchParkHasFeatureByParkID :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ?  
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkID(ctx context.Context, arg FetchParkHasFeatureByParkIDParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkID, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDAndStatus = `-- name: FetchParkHasFeatureByParkIDAndStatus :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ? AND status = ?  
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDAndStatusParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDAndStatus(ctx context.Context, arg FetchParkHasFeatureByParkIDAndStatusParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDAndStatus,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtASC = `-- name: FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtASC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtDESC = `-- name: FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDAndStatusOrderedByCreatedAtDESC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtASC = `-- name: FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtASC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtDESC = `-- name: FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDAndStatusOrderedByUpdatedAtDESC,
		arg.ParkID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDOrderedByCreatedAtASC = `-- name: FetchParkHasFeatureByParkIDOrderedByCreatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDOrderedByCreatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDOrderedByCreatedAtASC(ctx context.Context, arg FetchParkHasFeatureByParkIDOrderedByCreatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDOrderedByCreatedAtASC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDOrderedByCreatedAtDESC = `-- name: FetchParkHasFeatureByParkIDOrderedByCreatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDOrderedByCreatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByParkIDOrderedByCreatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDOrderedByCreatedAtDESC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDOrderedByUpdatedAtASC = `-- name: FetchParkHasFeatureByParkIDOrderedByUpdatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDOrderedByUpdatedAtASCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkHasFeatureByParkIDOrderedByUpdatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDOrderedByUpdatedAtASC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByParkIDOrderedByUpdatedAtDESC = `-- name: FetchParkHasFeatureByParkIDOrderedByUpdatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     park_id = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByParkIDOrderedByUpdatedAtDESCParams struct {
	ParkID string `json:"park_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByParkIDOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByParkIDOrderedByUpdatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByParkIDOrderedByUpdatedAtDESC, arg.ParkID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByStatus = `-- name: FetchParkHasFeatureByStatus :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchParkHasFeatureByStatusParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByStatus(ctx context.Context, arg FetchParkHasFeatureByStatusParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByStatusOrderedByCreatedAtASC = `-- name: FetchParkHasFeatureByStatusOrderedByCreatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByStatusOrderedByCreatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchParkHasFeatureByStatusOrderedByCreatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByStatusOrderedByCreatedAtDESC = `-- name: FetchParkHasFeatureByStatusOrderedByCreatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByStatusOrderedByCreatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByStatusOrderedByCreatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByStatusOrderedByUpdatedAtASC = `-- name: FetchParkHasFeatureByStatusOrderedByUpdatedAtASC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchParkHasFeatureByStatusOrderedByUpdatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchParkHasFeatureByStatusOrderedByUpdatedAtASCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchParkHasFeatureByStatusOrderedByUpdatedAtDESC = `-- name: FetchParkHasFeatureByStatusOrderedByUpdatedAtDESC :many
SELECT id, details, status, created_at, updated_at, park_id, feature_id FROM park_has_feature
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchParkHasFeatureByStatusOrderedByUpdatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchParkHasFeatureByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchParkHasFeatureByStatusOrderedByUpdatedAtDESCParams) ([]ParkHasFeature, error) {
	rows, err := q.db.QueryContext(ctx, fetchParkHasFeatureByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParkHasFeature
	for rows.Next() {
		var i ParkHasFeature
		if err := rows.Scan(
			&i.ID,
			&i.Details,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParkID,
			&i.FeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRecreationAreaByID = `-- name: FetchRecreationAreaByID :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
     id = ?
`

func (q *Queries) FetchRecreationAreaByID(ctx context.Context, id string) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, fetchRecreationAreaByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRecreationAreaByStatus = `-- name: FetchRecreationAreaByStatus :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchRecreationAreaByStatusParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchRecreationAreaByStatus(ctx context.Context, arg FetchRecreationAreaByStatusParams) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, fetchRecreationAreaByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRecreationAreaByStatusOrderedByCreatedAtASC = `-- name: FetchRecreationAreaByStatusOrderedByCreatedAtASC :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchRecreationAreaByStatusOrderedByCreatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchRecreationAreaByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchRecreationAreaByStatusOrderedByCreatedAtASCParams) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, fetchRecreationAreaByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRecreationAreaByStatusOrderedByCreatedAtDESC = `-- name: FetchRecreationAreaByStatusOrderedByCreatedAtDESC :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchRecreationAreaByStatusOrderedByCreatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchRecreationAreaByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchRecreationAreaByStatusOrderedByCreatedAtDESCParams) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, fetchRecreationAreaByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRecreationAreaByStatusOrderedByUpdatedAtASC = `-- name: FetchRecreationAreaByStatusOrderedByUpdatedAtASC :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchRecreationAreaByStatusOrderedByUpdatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchRecreationAreaByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchRecreationAreaByStatusOrderedByUpdatedAtASCParams) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, fetchRecreationAreaByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRecreationAreaByStatusOrderedByUpdatedAtDESC = `-- name: FetchRecreationAreaByStatusOrderedByUpdatedAtDESC :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchRecreationAreaByStatusOrderedByUpdatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchRecreationAreaByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchRecreationAreaByStatusOrderedByUpdatedAtDESCParams) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, fetchRecreationAreaByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmail = `-- name: FetchUserByEmail :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    LIMIT ?, ?
`

type FetchUserByEmailParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmail(ctx context.Context, arg FetchUserByEmailParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmail, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatus = `-- name: FetchUserByEmailAndStatus :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusParams struct {
	Email  string `json:"email"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatus(ctx context.Context, arg FetchUserByEmailAndStatusParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatus,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByCreatedAtASC = `-- name: FetchUserByEmailAndStatusOrderedByCreatedAtASC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByCreatedAtASCParams struct {
	Email  string `json:"email"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByCreatedAtASC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserByEmailAndStatusOrderedByCreatedAtDESC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByCreatedAtDESCParams struct {
	Email  string `json:"email"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByCreatedAtDESC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserByEmailAndStatusOrderedByUpdatedAtASC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByUpdatedAtASCParams struct {
	Email  string `json:"email"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByUpdatedAtASC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserByEmailAndStatusOrderedByUpdatedAtDESC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByUpdatedAtDESCParams struct {
	Email  string `json:"email"`
	Status int32  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByUpdatedAtDESC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByCreatedAtASC = `-- name: FetchUserByEmailOrderedByCreatedAtASC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByCreatedAtASCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByEmailOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByCreatedAtASC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByCreatedAtDESC = `-- name: FetchUserByEmailOrderedByCreatedAtDESC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByCreatedAtDESCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByEmailOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByCreatedAtDESC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByUpdatedAtASC = `-- name: FetchUserByEmailOrderedByUpdatedAtASC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByUpdatedAtASCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByEmailOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByUpdatedAtASC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByUpdatedAtDESC = `-- name: FetchUserByEmailOrderedByUpdatedAtDESC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByUpdatedAtDESCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByEmailOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByUpdatedAtDESC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByID = `-- name: FetchUserByID :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     id = ?
`

func (q *Queries) FetchUserByID(ctx context.Context, id string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatus = `-- name: FetchUserByStatus :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchUserByStatusParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatus(ctx context.Context, arg FetchUserByStatusParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByCreatedAtASC = `-- name: FetchUserByStatusOrderedByCreatedAtASC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByCreatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByStatusOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByCreatedAtDESC = `-- name: FetchUserByStatusOrderedByCreatedAtDESC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByCreatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByStatusOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByUpdatedAtASC = `-- name: FetchUserByStatusOrderedByUpdatedAtASC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByUpdatedAtASCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByStatusOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByUpdatedAtDESC = `-- name: FetchUserByStatusOrderedByUpdatedAtDESC :many
SELECT id, name, email, password, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByUpdatedAtDESCParams struct {
	Status int32 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByStatusOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFeature = `-- name: SearchFeature :many
SELECT id, name, status, created_at, updated_at, user_id FROM feature
WHERE 
    name like ? 
    LIMIT ?, ?
`

type SearchFeatureParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) SearchFeature(ctx context.Context, arg SearchFeatureParams) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, searchFeature, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPark = `-- name: SearchPark :many
SELECT id, name, main_image, phone, hours, allows_dogs, links, status, created_at, updated_at, recreation_area_id, user_id FROM park
WHERE 
    name like ? 
    LIMIT ?, ?
`

type SearchParkParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) SearchPark(ctx context.Context, arg SearchParkParams) ([]Park, error) {
	rows, err := q.db.QueryContext(ctx, searchPark, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Park
	for rows.Next() {
		var i Park
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MainImage,
			&i.Phone,
			&i.Hours,
			&i.AllowsDogs,
			&i.Links,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecreationAreaID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRecreationArea = `-- name: SearchRecreationArea :many
SELECT id, name, status, created_at, updated_at, user_id FROM recreation_area
WHERE 
    name like ? 
    LIMIT ?, ?
`

type SearchRecreationAreaParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) SearchRecreationArea(ctx context.Context, arg SearchRecreationAreaParams) ([]RecreationArea, error) {
	rows, err := q.db.QueryContext(ctx, searchRecreationArea, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecreationArea
	for rows.Next() {
		var i RecreationArea
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
